Застосунки поділені на дві основні секції пам'яті:
- Стек (Stack)
- Купа (Heap)
Ці секції пам'яті мають функціональні відмінності. Алокація в стеку працює швидше за алокацію в купі.

### Стек (Stack)
Змінна, що знаходиться в тілі функції (локальна змінна), зберігається в стеку. Стек - це місце, де зберігаються локальні змінні функції. Коли функція викликається, вона розміщається в стеку, а коли функція завершується, вона видаляється зі стеку.

```cpp
#include <iostream>
#include <string>

using String = std::string;

class Entity {
private:
    String m_Name;
public:
    Entity(): m_Name("Unknown") {}
    Entity(const String& name): m_Name(name) {}

    const String& GetName() const {
        return m_Name;
    }
}

void Function() {
    Entity entity = Entity("Andriy");
}

int main() {
    Entity entity; // ініціалізовано використовуючи конструктор за замовчуванням
    std::cout << entity.GetName() << std::endl;

    Entity entity1("Cherno"); // ініціалізовано використовуючи конструктор з параметрами
    // Entity entity1 = Entity("Cherno"); // те саме, що і рядком вище

    std::cin.get();
}
```

Якщо можна використовувать алокацію стека, то бажано використовувать саме її.

### Неправильне використання стека
вказівник на `e` вказує на об'єкт, який видалено зі стеку, коли закінчується блок (scope), в якому він був створений
```cpp
int main() {
    Entity* e;
    { // пустий блок (scope), по суті схоже на тіло функції
        Entity entity("Cherno");
        e = &entity;
    }
    std::cout << e->GetName() << std::endl; // видасть помилку, бо entity видалено зі стеку
    std::cin.get();
}
```

### Проблеми з пам'яттю для стека
Розмір стека обмежений (зазвичай 1-2 МБ). Якщо об'єкти класу Entity будуть занадто великими, то може виникнути помилка. Якщо використовувати рекурсію, то може виникнути помилка переповнення стека.

### Використання heap
Після ініціалізації об'єкта в купі, цей об'єкт потім потрібно видалити.
```cpp
int main() {
    Entity* e;
    {
        Entity* entity = new Entity("Cherno");
        e = entity;
    }
    std::cout << e->GetName() << std::endl; // не видасть помилку, бо entity зберігається в купі
    std::cin.get();
    delete e; // видалення об'єкта з купи
}
```

